/**
* Copyright (c) Lambda Innovation, 2013-2016
* This file is part of the AcademyCraft mod.
* https://github.com/LambdaInnovation/AcademyCraft
* Licensed under GPLv3, see project root for more information.
*/
package cn.academy.core.block;

import cn.academy.core.tile.TileInventory;
import cn.academy.energy.api.IFItemManager;
import cn.academy.energy.api.block.IWirelessGenerator;
import cn.lambdalib.annoreg.core.Registrant;
import cn.lambdalib.networkcall.RegNetworkCall;
import cn.lambdalib.networkcall.s11n.StorageOption;
import cn.lambdalib.networkcall.s11n.StorageOption.Data;
import cpw.mods.fml.relauncher.Side;
import net.minecraft.item.ItemStack;

/**
 * @author WeAthFolD
 */
@Registrant
public abstract class TileGeneratorBase extends TileInventory implements IWirelessGenerator {
    
    public final double bufferSize;
    public final double bandwidth;
    
    private int updateTicker = 20;
    
    /**
     * Amount of buffered energy.
     */
    private double energy;

    public TileGeneratorBase(String _invName, int size, double _bufferSize, double _bandwidth) {
        super(_invName, size);
        bufferSize = _bufferSize;
        bandwidth = _bandwidth;
    }
    
    @Override
    public void updateEntity() {
        if(!getWorldObj().isRemote) {
            double required = bufferSize - energy;
            energy += getGeneration(required);
            if (energy > bufferSize)
                energy = bufferSize;
            
            if(--updateTicker == 0) {
                updateTicker = 20;
                syncToClient(energy);
            }
        }
    }
    
    /**
     * Manually add [amt] energy into the buffer.
     * @return Energy not consumed
     */
    public double addEnergy(double amt) {
        return addEnergy(amt, false);
    }
    
    public double addEnergy(double amt, boolean simulate) {
        double add = Math.min(bufferSize - energy, amt);
        if(!simulate)
            energy += add;
        return amt - add;
    }

    @Override
    public double getProvidedEnergy(double req) {
        if(req > energy) req = energy;
        
        energy -= req;
        return req;
    }
    
    public double getEnergy() {
        return energy;
    }
    
    public void setEnergy(double energy) {
        this.energy = energy;
    }

    @Override
    public double getBandwidth() {
        return bandwidth;
    }
    
    /**
     * Try to charge a ItemStack with the buffer energy within the generator.
     */
    public void tryChargeStack(ItemStack stack) {
        if(IFItemManager.instance.isSupported(stack)) {
            double cangive = Math.min(energy, bandwidth);
            double ret = IFItemManager.instance.charge(stack, cangive);
            energy -= (cangive - ret);
        }
    }
    
    /**
     * Get the energy generated by the generator this tick.
     */
    public abstract double getGeneration(double required);
    
    @RegNetworkCall(side = Side.CLIENT, thisStorage = StorageOption.Option.INSTANCE)
    private void syncToClient(@Data Double energy) {
        this.energy = energy;
    }

}
